syntax = "proto3";
option go_package = "source.monogon.dev/metropolis/node/core/curator/proto/private";
package metropolis.node.core.curator.proto.private;

import "metropolis/proto/common/common.proto";
import "version/spec/spec.proto";

// Node describes a single node's state in etcd. This is only ever visible to
// the curator, and fully managed by the curator.
//
// Serialized nodes are stored in /nodes/$id, where $id is the node's ID as
// calculated from its public key.
message Node {
    // The node's public key.
    bytes public_key = 1;
    // Node's individual cluster part of the data partition encryption key. It
    // is combined with the Node Unlock Key (NUK) kept within
    // SealedConfiguration.
    bytes cluster_unlock_key = 2;

    // The node's state, as seen by the cluster. This state is persisted and
    // represents the progress the node is making through registering into the
    // cluster or joining the cluster.
    metropolis.proto.common.NodeState fsm_state = 3;

    // The node's intended roles when running.
    metropolis.proto.common.NodeRoles roles = 4;

    metropolis.proto.common.NodeStatus status = 5;

    // join_key is an ED25519 public key used to authenticate the join
    // operation. It's generated by the node during the registration process.
    bytes join_key = 6;

    // clusternet, if set, is a node's Cluster Networking configuration. See
    // metropolis.node.core.curator.api.Curator.UpdateNodeClusterNetworking for
    // more details.
    metropolis.proto.common.NodeClusterNetworking clusternet = 7;

    // tpm_usage describes whether this node has a TPM 2.0 and whether it's using
    // it.
    metropolis.proto.common.NodeTPMUsage tpm_usage = 8;

    metropolis.proto.common.NodeLabels labels = 9;
}

// Information about the cluster owner, currently the only Metropolis management
// entity, named 'owner' in public APIs.
//
// This is populated from NodeParameters.cluster_bootstrap.owner_public_key on
// cluster bootstrap.
//
// MVP: In the future, once we have implemented a manager/user entity system,
// this will be replaced by a proper per-user entry.
//
// Stored under /global/initial_owner (see curator.initialOwnerEtcdPath).
message InitialOwner {
    // ED25519 public key of cluster owner.
    bytes public_key = 1;
}

// A blob which needs to be provided by nodes registering into the cluster.
// Presenting this ticket on registration does not automatically grant access
// to arbitrary node registration. Instead it is used to guard the API surface
// of the Register RPC from potential denial of service attacks, and can be
// regenerated at any time in case it leaks.
//
// Stored under /global/register_ticket (see curator.registerTicketEtcdPath).
message RegisterTicket {
    bytes opaque = 1;
}

// KubernetesReconcilerStatus contains status reported by the reconciler.
// This is used by the reconciler itself, and it is used by the Kubernetes
// controller service to wait for reconciliation to be complete with a
// compatible version.
//
// Stored under /kubernetes/reconciler/status
message KubernetesReconcilerStatus {
    enum State {
        STATE_UNKNOWN = 0;
        STATE_DONE = 1;
        STATE_WORKING = 2;
    };
    // state tells whether reconciliation is in progress or complete.
    // This is shown in logs, but not otherwise used.
    State state = 1;

    // version is the Metropolis version of the node that last set the status.
    version.spec.Version version = 2;
    // minimum_compatible_release is the minimum Metropolis release which is
    // compatible with the changes made by the reconciler.
    // A Kubernetes controller must not start serving as long as this is higher
    // than its own release. This may not be increased if there are
    // Kubernetes controllers with a lower release than the new value.
    version.spec.Version.Release minimum_compatible_release = 3;
}
